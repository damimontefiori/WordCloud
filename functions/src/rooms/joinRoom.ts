import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import { Timestamp, FieldValue } from 'firebase-admin/firestore';
import { generateUniqueParticipantName, createErrorResponse, createSuccessResponse } from '../utils/helpers';
import { COLLECTIONS, ROOM_STATES, ERROR_CODES, MAX_PARTICIPANTS_PER_ROOM } from '../utils/constants';

const db = admin.firestore();

interface JoinRoomRequest {
  roomCode: string;
  participantName?: string;
  sessionId: string; // Generated by client to prevent duplicates
}

export const joinRoom = functions.https.onCall(async (data: JoinRoomRequest, context) => {
  try {
    const { roomCode, participantName = '', sessionId } = data;

    if (!roomCode || !sessionId) {
      return createErrorResponse(ERROR_CODES.INVALID_INPUT, 'Código de sala y ID de sesión son requeridos');
    }

    // Find room by code
    const roomQuery = await db.collection(COLLECTIONS.ROOMS)
      .where('code', '==', roomCode.toUpperCase())
      .limit(1)
      .get();

    if (roomQuery.empty) {
      return createErrorResponse(ERROR_CODES.ROOM_NOT_FOUND, 'Sala no encontrada');
    }

    const roomDoc = roomQuery.docs[0];
    const roomData = roomDoc.data();

    // Check if room is expired
    if (roomData.expiresAt.toDate() < new Date()) {
      return createErrorResponse(ERROR_CODES.ROOM_EXPIRED, 'La sala ha expirado');
    }

    // Check if room is finished
    if (roomData.isFinished || roomData.state === ROOM_STATES.FINISHED) {
      return createErrorResponse(ERROR_CODES.ROOM_FINISHED, 'La sala ha finalizado');
    }

    // Check participant limit
    if (roomData.participantCount >= MAX_PARTICIPANTS_PER_ROOM) {
      return createErrorResponse(ERROR_CODES.ROOM_FULL, 'La sala está llena');
    }

    // Check if participant already exists (by sessionId)
    const existingParticipant = await db.collection(COLLECTIONS.PARTICIPANTS)
      .where('roomId', '==', roomDoc.id)
      .where('sessionId', '==', sessionId)
      .limit(1)
      .get();

    if (!existingParticipant.empty) {
      const participantData = existingParticipant.docs[0].data();
      return createSuccessResponse({
        participantId: existingParticipant.docs[0].id,
        participantName: participantData.name,
        roomTitle: roomData.title,
        roomState: roomData.state,
        hasVoted: participantData.hasVoted,
        isActive: roomData.isActive,
        requiresConfirmation: roomData.requiresConfirmation
      });
    }

    // Get existing participant names to ensure uniqueness
    const existingParticipants = await db.collection(COLLECTIONS.PARTICIPANTS)
      .where('roomId', '==', roomDoc.id)
      .get();

    const existingNames = existingParticipants.docs.map(doc => doc.data().name);

    // Generate unique participant name
    const uniqueName = generateUniqueParticipantName(participantName, existingNames);

    // Create participant document
    const now = Timestamp.now();
    const participantData = {
      roomId: roomDoc.id,
      name: uniqueName,
      originalName: participantName.trim() || 'Invitado',
      sessionId,
      hasVoted: false,
      joinedAt: now,
      lastSeen: now,
      isActive: true
    };

    const participantRef = await db.collection(COLLECTIONS.PARTICIPANTS).add(participantData);

    // Update room participant count
    await roomDoc.ref.update({
      participantCount: FieldValue.increment(1)
    });

    return createSuccessResponse({
      participantId: participantRef.id,
      participantName: uniqueName,
      roomTitle: roomData.title,
      roomState: roomData.state,
      hasVoted: false,
      isActive: roomData.isActive,
      requiresConfirmation: roomData.requiresConfirmation,
      timeLimit: roomData.timeLimit,
      startedAt: roomData.startedAt
    });

  } catch (error) {
    console.error('Error joining room:', error);
    return createErrorResponse(ERROR_CODES.INVALID_INPUT, 'Error interno del servidor');
  }
});
